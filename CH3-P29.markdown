#第三章 基本概念

##3.1 语法

###3.1.1 区分大小写

###3.1.2 标识符

- 标识符就是指变量、函数、属性的名字或者函数的参数
- 第一个字符必须是一个字母、下划线、美元符号或数字
- 其他字符可以是字符、下划线、美元符号或数字
- 标识符中的字母也可以包含扩展的ASCII或Unicode字母字符，但不推荐使用
- 驼峰写法
- 关键字、保留字、true、false和null不能用作标识符

###3.1.3 注释

``` js
//单行注释
/*
 * 这是一个多行
 * （块级）注释
 */
```

###3.1.4 严格模式

- 如果要在整个脚本中启用严格模式，可以在顶部添加：“use strict";
- 也可以对指定函数使用严格模式

``` js
function doSomething(){
  "use strict";
  //函数体
}
```

###3.1.5 语句

- 推荐给语句结尾都加上分号
- 可以使用C风格的语法把多条语句组合到一个代码块中，用{}括起来
- 条件控制语句（如if），即使只有一条语句，也推荐同花括号括起来

##3.2 关键字和保留字

ECMA-262 描述了一组具有特定用途的关键字

**关键字**

> break do instanceof typeof case else new var catch finally return void continue for switch while debugger* function this with default if throw delete in try 


ECMA-262 还描述了另外一组不能用作标识符的保留字

**保留字**

> abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public


第 5 版把在非严格模式下运行时的保留字缩减为下列这些:

> class enum extends super const export import 


在严格模式下，第 5 版还对以下保留字施加了限制：

> implements package public interface private static let protected yield 

ECMA-262 第 5 版对 eval 和 arguments 还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。

##3.3 变量

``` js
var message1; //未经初始化的变量，会保存一个特殊的值——undefined
var message2 = 'hi'; //直接初始化变量
message2 = 100; //有效，但不推荐

function test1(){
    var message3 = 'hi'; //局部变量，用var操作符定义的变量成为定义该变量作用域中的局部变量
}
test1(); //函数调用时，会创建该变量并赋值；之后变量会被立即销毁
alert(message3); //错误！

function test2(){
    message4 = 'hi'; //全局变量，没有var
}
test2();
alert(message4); //'hi'
```

``` js
//一条语句定义多个变量，推荐缩进格式
var message = 'hi',
    found = false,
    age = 29;
```

##3.4 数据类型

ECMAScript中有五种简单数据类型：Undefined、Null、Boolean、Number、String；一种复杂数据类型：Object。Object本质上是由一组无序的键值对组成的。

###3.4.1 typeof操作符

typeof操作符返回的永远都是字符串：

- "undefined" —— 如果这个值未定义
- "boolean" ——如果这个值是布尔值
- "string" ——如果这个值是字符串
- ”number" ——如果这个值是数值
- "object" ——如果这个值是对象或null
- "function" ——如果这个值是函数

``` js
var message = "some string"; 
alert(typeof message);     // "string"  // 注意 typeof 返回的都是字符串类型
alert(typeof(message));    // "string"  // typeof 操作变量
alert(typeof 95);          // "number"  // typeof 操作数值字面量
// typeof 是一个操作符而不是一个函数，因此例子中的圆括号尽管可以使用，但不是必需的。

var a = function(){alert(1)}
alert(typeof a); //"function" //虽然函数也是一种对象，但是函数尤其特殊性，因此用typeof将function从object中区分出来是有必要的。
```

> typeof null 会返回 "object"，因为 null 被认为是一个空的对象引用。
> typeof 正则表达式 在大多数情况下返回 "object"，但是在Safari 5及之前版本、Chrome 7及之前版本会返回 "function"

###3.4.2 Undefined 类型

Undefined类型只有一个值：undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。

``` js
var message;
alert(message == undefined); //true
```

上述例子等价于下面的例子：

``` js
var message = undefined; //单单写 var message 就相当于将undefined赋给了这个变量
alert(message == undefined); //true
```

注意，undefined有两个条件：1、用var声明了；2、未对其初始化

``` js
var message; //变量声明后默认取得undefined值

//var age //该变量并没有被声明，因为在注释里
alert(message); //"undefined"
alert(age); //产生错误
```

对于尚未声明过的变量，只能执行一项操作，就是使用typeof操作符检测其数据类型。如果变量未声明，用typeof来操作，也会返回"undefined"。对未声明的变量执行typeof操作符也同样返回"undefined"

``` js
var message; // 声明但未初始化，默认获得 undefined 值
//var age //未声明的变量

alert(typeof message); //"undefined"
alert(typeof age); //"undefined"
```

> 即使未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择，如果能做到这一点，那么当typeof操作符返回"undefined"值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。

###3.4.3 Null类型

Null类型也只有一个值null。null值表示一个空对象指针，因此 typeof null返回的是"object"。

``` js
var car = null;
alert(typeof null); //"object"
```

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如：

``` js
if (car != null) {
    //对 car 对象执行某些操作
}
```

> 实际上，undefined 值是派生自 null 值的，因此ECMA-262规定对它们的相等性测试要返回true，如：

``` js
alert(null == undefined); //true
```

无论什么情况下，都没有必要把一个变量的值显示设置为 undefined，但是只要意在保存对象的变量还没有真正保存对象，就应该明确让该变量保存 null 值。这样不仅可以体现 null 作为空对象指针的惯例，也有助于进一步区分 null 和 undefined 。

###3.4.4 Boolean类型

该类型有两个字面值：true 和 false。注意这两个字面值是区分大小写的。

ECMAScript中所有类型的值都有与这两个Boolean值等价的值，可以通过调用转型函数Boolean()来实现：

``` js
var message = "Hello world!";
var messageAsBoolean = Boolean(message);
```

数据类型 | 转换为 true 的值 | 转换为 false 的值
:--|:--|:--
Boolean | true | false
String | 任何非空字符串 | "" （空字符串）
Number | 任何非零数字值（包括无穷大） | 0和NaN
Object | 任何对象 | null
Undefined | n/a | undefined

这些转换规则对于理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要，如：

``` js
var message = "Hello world!";
if(message){
    alert("Value is true.");
}
//运行上述代码会弹出警告框，因为字符串message被自动转换成了对应的Boolean值(true)。
```

###3.4.5 Number类型

这种类型使用IEEE754格式来表示整数和浮点数值。

- 十进制整数 `var intNum = 55; //整数`
- 八进制 `var octalNum1 = 070; //八进制的56`
    - 八进制字面量的第一位必须是零
    - 八进制字面量中的数字是 0~7，超出该范围无效
        - `var octalNum2 = 079; //无效八进制——解析为79`
        - `var octalNum3 = 08; //无效的八进制——解析为8`
    - 八进制字面量在严格模式下无效，会导致js引擎抛出错误
- 十六进制 `var hexNum1 = 0xA; //十六进制的10` 
    - `var hexNum2 = 0x1f; //十六进制的31`
    - 十六进制字面值的前两位必须是0x
    - 后面跟任何十六进制数字0~9、A~F，其中字母大小写皆可
- 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

####1. 浮点数值

数值中必须包含一个小数点，且小数点后面必须至少有一位数字。

``` js
var floatNum1 = 1.1;
var floatNum2 = 0.1;
var float Num3 = .1; //有效，但不推荐
```

由于浮点数保存需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换成整数值：

``` js
var floatNum1 = 1.; //小数点后面没有数字——解析为1
var floatNum2 = 10.0 //整数——解析为10
```

对于极大或极小的数值，用e表示法（科学计数法）：

``` js
var floatNum1 = 3.125e7; //就相当于是 3.123 × 10 ^7 即 31250000
var floatNum2 = 3e-7; //就是0.0000003
```

浮点数值的最高精度是17位小数，进行算术计算其精确度远不如整数，如：0.1加0.2的结果不是0.3，而是0.30000000000000004。

``` js
if (a + b == 0.3) { //不要做这样的测试！
    alert("You got 0.3."); 
}
//如果a、b两个数是0.05和0.25或者0.15和0.15都不会有问题，但是如果两个数是0.1和0.2，那么测试将无法通过。
```

####2. 数值范围

ECMAScript能够表示的最小数值保存在 Number.MIN_VALUE中，大多数浏览器中这个值为 5e-324，小于这个值就会被自动转换成 -Infinity（负无穷）；最大的值保存在 Number.MAX_VALUE中，大多数浏览器中这个值为 1.7976931348623157e+308，大于它会被转成 Infinity（正无穷）。

如果某次计算反回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算。可以用 isFinite() 函数确定一个数值是否是有穷的：

``` js
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false
```

> 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值。可以想见，这两个属性中分别保存着 -Infinity 和 Infinity 。
