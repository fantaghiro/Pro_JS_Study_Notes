#第三章 基本概念

##3.1 语法

###3.1.1 区分大小写

###3.1.2 标识符

- 标识符就是指变量、函数、属性的名字或者函数的参数
- 第一个字符必须是一个字母、下划线、美元符号或数字
- 其他字符可以是字符、下划线、美元符号或数字
- 标识符中的字母也可以包含扩展的ASCII或Unicode字母字符，但不推荐使用
- 驼峰写法
- 关键字、保留字、true、false和null不能用作标识符

###3.1.3 注释

``` js
//单行注释
/*
 * 这是一个多行
 * （块级）注释
 */
```

###3.1.4 严格模式

- 如果要在整个脚本中启用严格模式，可以在顶部添加：“use strict";
- 也可以对指定函数使用严格模式

``` js
function doSomething(){
  "use strict";
  //函数体
}
```

###3.1.5 语句

- 推荐给语句结尾都加上分号
- 可以使用C风格的语法把多条语句组合到一个代码块中，用{}括起来
- 条件控制语句（如if），即使只有一条语句，也推荐同花括号括起来

##3.2 关键字和保留字

ECMA-262 描述了一组具有特定用途的关键字

**关键字**

> break do instanceof typeof case else new var catch finally return void continue for switch while debugger* function this with default if throw delete in try 


ECMA-262 还描述了另外一组不能用作标识符的保留字

**保留字**

> abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public


第 5 版把在非严格模式下运行时的保留字缩减为下列这些:

> class enum extends super const export import 


在严格模式下，第 5 版还对以下保留字施加了限制：

> implements package public interface private static let protected yield 

ECMA-262 第 5 版对 eval 和 arguments 还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。

##3.3 变量

``` js
var message1; //未经初始化的变量，会保存一个特殊的值——undefined
var message2 = 'hi'; //直接初始化变量
message2 = 100; //有效，但不推荐

function test1(){
    var message3 = 'hi'; //局部变量，用var操作符定义的变量成为定义该变量作用域中的局部变量
}
test1(); //函数调用时，会创建该变量并赋值；之后变量会被立即销毁
alert(message3); //错误！

function test2(){
    message4 = 'hi'; //全局变量，没有var
}
test2();
alert(message4); //'hi'
```

``` js
//一条语句定义多个变量，推荐缩进格式
var message = 'hi',
    found = false,
    age = 29;
```

##3.4 数据类型

ECMAScript中有五种简单数据类型：Undefined、Null、Boolean、Number、String；一种复杂数据类型：Object。Object本质上是由一组无序的键值对组成的。

###3.4.1 typeof操作符

typeof操作符返回的永远都是字符串：

- "undefined" —— 如果这个值未定义
- "boolean" ——如果这个值是布尔值
- "string" ——如果这个值是字符串
- ”number" ——如果这个值是数值
- "object" ——如果这个值是对象或null
- "function" ——如果这个值是函数

``` js
var message = "some string"; 
alert(typeof message);     // "string"  // 注意 typeof 返回的都是字符串类型
alert(typeof(message));    // "string"  // typeof 操作变量
alert(typeof 95);          // "number"  // typeof 操作数值字面量
// typeof 是一个操作符而不是一个函数，因此例子中的圆括号尽管可以使用，但不是必需的。

var a = function(){alert(1)}
alert(typeof a); //"function" //虽然函数也是一种对象，但是函数尤其特殊性，因此用typeof将function从object中区分出来是有必要的。
```

> typeof null 会返回 "object"，因为 null 被认为是一个空的对象引用。
> typeof 正则表达式 在大多数情况下返回 "object"，但是在Safari 5及之前版本、Chrome 7及之前版本会返回 "function"

###3.4.2 Undefined 类型

Undefined类型只有一个值：undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。

``` js
var message;
alert(message == undefined); //true
```

上述例子等价于下面的例子：

``` js
var message = undefined; //单单写 var message 就相当于将undefined赋给了这个变量
alert(message == undefined); //true
```

注意，undefined有两个条件：1、用var声明了；2、未对其初始化

``` js
var message; //变量声明后默认取得undefined值

//var age //该变量并没有被声明，因为在注释里
alert(message); //"undefined"
alert(age); //产生错误
```

对于尚未声明过的变量，只能执行一项操作，就是使用typeof操作符检测其数据类型。如果变量未声明，用typeof来操作，也会返回"undefined"。对未声明的变量执行typeof操作符也同样返回"undefined"

``` js
var message; // 声明但未初始化，默认获得 undefined 值
//var age //未声明的变量

alert(typeof message); //"undefined"
alert(typeof age); //"undefined"
```

> 即使未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择，如果能做到这一点，那么当typeof操作符返回"undefined"值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。

###3.4.3 Null类型

Null类型也只有一个值null。null值表示一个空对象指针，因此 typeof null返回的是"object"。

``` js
var car = null;
alert(typeof null); //"object"
```

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如：

``` js
if (car != null) {
    //对 car 对象执行某些操作
}
```

> 实际上，undefined 值是派生自 null 值的，因此ECMA-262规定对它们的相等性测试要返回true，如：

``` js
alert(null == undefined); //true
```

无论什么情况下，都没有必要把一个变量的值显示设置为 undefined，但是只要意在保存对象的变量还没有真正保存对象，就应该明确让该变量保存 null 值。这样不仅可以体现 null 作为空对象指针的惯例，也有助于进一步区分 null 和 undefined 。

###3.4.4 Boolean类型

该类型有两个字面值：true 和 false。注意这两个字面值是区分大小写的。

ECMAScript中所有类型的值都有与这两个Boolean值等价的值，可以通过调用转型函数Boolean()来实现：

``` js
var message = "Hello world!";
var messageAsBoolean = Boolean(message);
```

数据类型 | 转换为 true 的值 | 转换为 false 的值
:--|:--|:--
Boolean | true | false
String | 任何非空字符串 | "" （空字符串）
Number | 任何非零数字值（包括无穷大） | 0和NaN
Object | 任何对象 | null
Undefined | n/a | undefined

这些转换规则对于理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要，如：

``` js
var message = "Hello world!";
if(message){
    alert("Value is true.");
}
//运行上述代码会弹出警告框，因为字符串message被自动转换成了对应的Boolean值(true)。
```

###3.4.5 Number类型

这种类型使用IEEE754格式来表示整数和浮点数值。

- 十进制整数 `var intNum = 55; //整数`
- 八进制 `var octalNum1 = 070; //八进制的56`
    - 八进制字面量的第一位必须是零
    - 八进制字面量中的数字是 0~7，超出该范围无效
        - `var octalNum2 = 079; //无效八进制——解析为79`
        - `var octalNum3 = 08; //无效的八进制——解析为8`
    - 八进制字面量在严格模式下无效，会导致js引擎抛出错误
- 十六进制 `var hexNum1 = 0xA; //十六进制的10` 
    - `var hexNum2 = 0x1f; //十六进制的31`
    - 十六进制字面值的前两位必须是0x
    - 后面跟任何十六进制数字0~9、A~F，其中字母大小写皆可
- 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

####1. 浮点数值

数值中必须包含一个小数点，且小数点后面必须至少有一位数字。

``` js
var floatNum1 = 1.1;
var floatNum2 = 0.1;
var float Num3 = .1; //有效，但不推荐
```

由于浮点数保存需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换成整数值：

``` js
var floatNum1 = 1.; //小数点后面没有数字——解析为1
var floatNum2 = 10.0 //整数——解析为10
```

对于极大或极小的数值，用e表示法（科学计数法）：

``` js
var floatNum1 = 3.125e7; //就相当于是 3.123 × 10 ^7 即 31250000
var floatNum2 = 3e-7; //就是0.0000003
```

浮点数值的最高精度是17位小数，进行算术计算其精确度远不如整数，如：0.1加0.2的结果不是0.3，而是0.30000000000000004。

``` js
if (a + b == 0.3) { //不要做这样的测试！
    alert("You got 0.3."); 
}
//如果a、b两个数是0.05和0.25或者0.15和0.15都不会有问题，但是如果两个数是0.1和0.2，那么测试将无法通过。
```

####2. 数值范围

ECMAScript能够表示的最小数值保存在 Number.MIN_VALUE中，大多数浏览器中这个值为 5e-324，小于这个值就会被自动转换成 -Infinity（负无穷）；最大的值保存在 Number.MAX_VALUE中，大多数浏览器中这个值为 1.7976931348623157e+308，大于它会被转成 Infinity（正无穷）。

如果某次计算反回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算。可以用 isFinite() 函数确定一个数值是否是有穷的：

``` js
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false
```

> 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值。可以想见，这两个属性中分别保存着 -Infinity 和 Infinity 。

####3. NaN

NaN，即非数值（Not a Number）是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况。例如，在ECMAScript中，0除以0会返回NaN，不会抛出错误，影响其他代码的执行。（整数除以0得到Infinity；负数除以0得到 -Infinity）

NaN的两个特点：

1. 任何涉及NaN的操作（例如NaN/10）都会返回NaN。
2. NaN与任何值都不相等，包括NaN本身。例如：`alert(NaN == NaN); //false`

ECMAScript定义了isNaN()函数，来确定参数是否“不是数值”。任何不能被转换为数值的值都会导致这个函数返回true，例如：

``` js
alert(isNaN(NaN)); //true
alert(isNaN(10)); //false (10是一个数值)
alert(isNaN("10")); // false (可以被转换成数值10)
alert(isNaN("blue")); //true (不能转换成数值)
alert(isNaN(true)); //false (可以被转换成数值1)
```

> isNaN()也适用于对象，它会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则给予这个返回值再调用toString()方法，再测试返回值。

####数值转换

- Number() 函数，可用于任何数据类型
- parseInt() 函数，专门用于把字符串转换成数值
- parseFloat() 函数，专门用于把字符串转换成数值

**转型函数Number() 的转换规则**

- 如果是Boolean值，true和false将分别转换为1和0
- 如果是数字值，知识简单的传入和返回
- 如果是null值，返回0
- 如果是undefined，返回NaN。
- 如果是字符串，则
    - 如果字符串只包含数字（包含前面带正、负号的情况），则将其转换为十进制数值，即"1"会变成1；"123"会变成123，而"011"会变成11（注意，前导的零被忽略）
    - 如果字符串中包含有效的浮点格式，如"1.1"，则将会转换为对应的浮点数值（前导零也会被忽略）
    - 如果字符串中包含有效的十六进制格式，例如"0xf"，则转换为相同大小的十进制整数值
    - 如果字符串为空（不包含任何字符），则转换为0
    - 如果字符串中包含上述格式之外的字符，则转换为NaN
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

``` js
var num1 = Number("Hello world!"); //NaN
var num2 = number(""); //0
var num3 = Number("000011"); //11
var num4 = Number(true); //1
```

**parseInt() 函数**

- 它会忽略字符串前面的空格，直至找到第一个非空格字符串
- 如果第一个字符不是数字字符或者负号，则返回NaN，例如`alert(parseInt("hi123")); //NaN`
- 转换空字符串，会返回NaN：`alert(parseInt("")); //NaN`
- 如果第一个字符是数字字符，则会继续解析第二个字符，直至解析完所有后续字符或者遇到了一个非数字字符。例如：`alert(parseInt("1234blue")); //1234`。又如：`alert(parseInt("22.5")); //22 因为小数点不是有效的数字字符`
- 也能够识别出各种整数格式，如果字符串以"0x"开头且后跟数字字符，就会当作一个十六进制整数；如果字符串以"0"开头且后跟数字字符，则会当作八进制数来解析。

``` js
var num1 = parseInt("1234blue"); //1234
var num2 = parseInt(""); //NaN
var num3 = parseInt("0xA"); //10 （十六进制数）
var num4 = parseInt(22.5); //22
var num5 = parseInt("070"); //56 （八进制数）
var num6 = parseInt("70"); //70 （十进制数）
var num7 = parseInt("0xf"); //15 （十六进制数）
```

> ECMAScript 3 JS引擎与5的JS引擎有区别。`var num = parseInt("070");` 在3中被认为是56（八进制）；在5中认为是70（十进制）

parseInt()函数的第二个参数：转换时使用的基数（即多少进制）：

``` js
var num = parseInt("0xAF", 16); //175
var num1 = parseInt("AF", 16); //175 指定了进制之后，字符串前面可以不带"0x"
var num2 = parseInt("AF"); //NaN
```

指定基数会影响到转换的输出结果，如：

``` js
var num1 = parseInt("10", 2); //2 （按二进制解析）
var num2 = parseInt("10", 8); //8 （按八进制解析）
var num3 = parseInt("10", 10); //10 （按十进制解析）
var num4 = parseInt("10", 16); //16 （按十六进制解析）
```

**parseFloat()函数**

- 从第一个字符（位置0）开始解析每个字符，一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。（字符串中第一个小数点是有效的，第二个小数点是无效的），如：`parseFloat("22.34.5"); //22.34`
- parseFloat()之中会忽略前导的零，它只解析十进制值，它没有第二个参数指定进制。十六进制的字符串始终解析为0，如`parseFloat("0xA"); //0`
- 如果字符串包含的是一个课解析为整数的数（没有小数点，或者小数点后都是零），那么parseFloat()会返回整数

``` js
var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000
```

###3.4.6 String类型

String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。可由双引号（"）或单引号（'）表示。用双引号或单引号表示的字符串完全相同。不过以双引号开头的字符串必须以双引号结尾；以单引号开头的字符串必须以单引号结尾，即左右引号必须匹配。

####1. 字符字面量

字面量 | 含义
:--|:--
\n | 换行
\t | 制表
\b | 空格
\r | 回车
\f | 进纸
\\ | 斜杠
\' | 单引号（'），在用单引号表示的字符串中使用，例如：`'He said, \'hey.\''`
\" | 双引号（"），在用双引号表示的字符串中使用，例如：`"He said, \"hey.\""`
\xnn | 以十六进制代码nn表示的一个字符（其中n为0~F）。例如，\x41表示"A"
\unnnn | 以十六进制代码nnnn表示一个Unicode字符（其中n为0~F）。例如，\u03a3表示希腊字符∑

以上这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析。如：

``` js
var text = "This is the letter sigma: \u03a3.";
alert(text.length); //输出28
```

####2. 字符串的特点

ECMAScript中的字符串是不可变的，即字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首相要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。例如：

``` js
var lang = "Java";
lang = lang + "Script";
```

以上示例的实现过程如下：先创建一个能容纳10个字符的新字符串，然后在这个字符串中填空“Java”和“Script”，最后一步是销毁原来的字符串“Java”和字符串“Script”。

####3. 转换为字符串

**方法一：toString()方法**

- 数值、布尔值、对象和字符串值（每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法
- null和undefined值没有这个方法，会报错
- 在调用数值的toString()方法时，可以传递一个参数，输出数值的基数，默认情况下，toString()方法以十进制格式返回数值的字符串表示。

``` js
var age = 11;
var ageAsString = age.toString(); //字符串"11"
var found = true;
var foundAsString = found.toString(); //字符串"true"

var num = 10;
alert(num.toString()); //"10"
alert(num.toString(2)); //"1010"
alert(num.toString(8)); //"12"
alert(num.toString(10)); //10
alert(num.toString(16)); //"a"
```

**方法二：转型函数String()**

在不知道要转换的值是不是null或undefined的情况下，还可以使用String()，它可以将任何类型的值转换为字符串。规则如下：

- 如果值有toString()方法，则调用该方法（没有参数），并返回相应结果
- 如果值是null，则返回"null"
- 如果值是undefined，则返回"undefined"

``` js
var value1 = 10;
var value2 = true;
var value3 = null;
var value4;

alert(String(value1)); //"10"
alert(String(value2)); //true;
alert(String(value3)); "null"
alert(String(value4)); "undefined"
```

**方法三：要把某个值转换为字符串，可以使用加号操作符把它与一个字符串("")加在一起**



