#第三章 基本概念

##3.1 语法

###3.1.1 区分大小写

###3.1.2 标识符

- 标识符就是指变量、函数、属性的名字或者函数的参数
- 第一个字符必须是一个字母、下划线、美元符号或数字
- 其他字符可以是字符、下划线、美元符号或数字
- 标识符中的字母也可以包含扩展的ASCII或Unicode字母字符，但不推荐使用
- 驼峰写法
- 关键字、保留字、true、false和null不能用作标识符

###3.1.3 注释

``` js
//单行注释
/*
 * 这是一个多行
 * （块级）注释
 */
```

###3.1.4 严格模式

- 如果要在整个脚本中启用严格模式，可以在顶部添加：“use strict";
- 也可以对指定函数使用严格模式

``` js
function doSomething(){
  "use strict";
  //函数体
}
```

###3.1.5 语句

- 推荐给语句结尾都加上分号
- 可以使用C风格的语法把多条语句组合到一个代码块中，用{}括起来
- 条件控制语句（如if），即使只有一条语句，也推荐同花括号括起来

##3.2 关键字和保留字

ECMA-262 描述了一组具有特定用途的关键字

**关键字**

> break do instanceof typeof case else new var catch finally return void continue for switch while debugger* function this with default if throw delete in try 


ECMA-262 还描述了另外一组不能用作标识符的保留字

**保留字**

> abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public


第 5 版把在非严格模式下运行时的保留字缩减为下列这些:

> class enum extends super const export import 


在严格模式下，第 5 版还对以下保留字施加了限制：

> implements package public interface private static let protected yield 

ECMA-262 第 5 版对 eval 和 arguments 还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。

##3.3 变量

``` js
var message1; //未经初始化的变量，会保存一个特殊的值——undefined
var message2 = 'hi'; //直接初始化变量
message2 = 100; //有效，但不推荐

function test1(){
    var message3 = 'hi'; //局部变量，用var操作符定义的变量成为定义该变量作用域中的局部变量
}
test1(); //函数调用时，会创建该变量并赋值；之后变量会被立即销毁
alert(message3); //错误！

function test2(){
    message4 = 'hi'; //全局变量，没有var
}
test2();
alert(message4); //'hi'
```

``` js
//一条语句定义多个变量，推荐缩进格式
var message = 'hi',
    found = false,
    age = 29;
```

##3.4 数据类型

ECMAScript中有五种简单数据类型：Undefined、Null、Boolean、Number、String；一种复杂数据类型：Object。Object本质上是由一组无序的键值对组成的。

###3.4.1 typeof操作符

typeof操作符返回的永远都是字符串：

- "undefined" —— 如果这个值未定义
- "boolean" ——如果这个值是布尔值
- "string" ——如果这个值是字符串
- ”number" ——如果这个值是数值
- "object" ——如果这个值是对象或null
- "function" ——如果这个值是函数

``` js
var message = "some string"; 
alert(typeof message);     // "string"  // 注意 typeof 返回的都是字符串类型
alert(typeof(message));    // "string"  // typeof 操作变量
alert(typeof 95);          // "number"  // typeof 操作数值字面量
// typeof 是一个操作符而不是一个函数，因此例子中的圆括号尽管可以使用，但不是必需的。

var a = function(){alert(1)}
alert(typeof a); //"function" //虽然函数也是一种对象，但是函数尤其特殊性，因此用typeof将function从object中区分出来是有必要的。
```

> typeof null 会返回 "object"，因为 null 被认为是一个空的对象引用。
> typeof 正则表达式 在大多数情况下返回 "object"，但是在Safari 5及之前版本、Chrome 7及之前版本会返回 "function"

###3.4.2 Undefined 类型

Undefined类型只有一个值：undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。

``` js
var message;
alert(message == undefined); //true
```

上述例子等价于下面的例子：

``` js
var message = undefined; //单单写 var message 就相当于将undefined赋给了这个变量
alert(message == undefined); //true
```

注意，undefined有两个条件：1、用var声明了；2、未对其初始化

``` js
var message; //变量声明后默认取得undefined值

//var age //该变量并没有被声明，因为在注释里
alert(message); //"undefined"
alert(age); //产生错误
```

对于尚未声明过的变量，只能执行一项操作，就是使用typeof操作符检测其数据类型。如果变量未声明，用typeof来操作，也会返回"undefined"。对未声明的变量执行typeof操作符也同样返回"undefined"

``` js
var message; // 声明但未初始化，默认获得 undefined 值
//var age //未声明的变量

alert(typeof message); //"undefined"
alert(typeof age); //"undefined"
```

> 即使未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择，如果能做到这一点，那么当typeof操作符返回"undefined"值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。

###3.4.3 Null类型

Null类型也只有一个值null。null值表示一个空对象指针，因此 typeof null返回的是"object"。

``` js
var car = null;
alert(typeof null); //"object"
```

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如：

``` js
if (car != null) {
    //对 car 对象执行某些操作
}
```

> 实际上，undefined 值是派生自 null 值的，因此ECMA-262规定对它们的相等性测试要返回true，如：

``` js
alert(null == undefined); //true
```

无论什么情况下，都没有必要把一个变量的值显示设置为 undefined，但是只要意在保存对象的变量还没有真正保存对象，就应该明确让该变量保存 null 值。这样不仅可以体现 null 作为空对象指针的惯例，也有助于进一步区分 null 和 undefined 。

###3.4.4 Boolean类型

该类型有两个字面值：true 和 false。注意这两个字面值是区分大小写的。

ECMAScript中所有类型的值都有与这两个Boolean值等价的值，可以通过调用转型函数Boolean()来实现：

``` js
var message = "Hello world!";
var messageAsBoolean = Boolean(message);
```

数据类型 | 转换为 true 的值 | 转换为 false 的值
:--|:--|:--
Boolean | true | false
String | 任何非空字符串 | "" （空字符串）
Number | 任何非零数字值（包括无穷大） | 0和NaN
Object | 任何对象 | null
Undefined | n/a | undefined

这些转换规则对于理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要，如：

``` js
var message = "Hello world!";
if(message){
    alert("Value is true.");
}
//运行上述代码会弹出警告框，因为字符串message被自动转换成了对应的Boolean值(true)。
```

###3.4.5 Number类型

这种类型使用IEEE754格式来表示整数和浮点数值。

- 十进制整数 `var intNum = 55; //整数`
- 八进制 `var octalNum1 = 070; //八进制的56`
    - 八进制字面量的第一位必须是零
    - 八进制字面量中的数字是 0~7，超出该范围无效
        - `var octalNum2 = 079; //无效八进制——解析为79`
        - `var octalNum3 = 08; //无效的八进制——解析为8`
    - 八进制字面量在严格模式下无效，会导致js引擎抛出错误
- 十六进制 `var hexNum1 = 0xA; //十六进制的10` 
    - `var hexNum2 = 0x1f; //十六进制的31`
    - 十六进制字面值的前两位必须是0x
    - 后面跟任何十六进制数字0~9、A~F，其中字母大小写皆可
- 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

####1. 浮点数值

数值中必须包含一个小数点，且小数点后面必须至少有一位数字。

``` js
var floatNum1 = 1.1;
var floatNum2 = 0.1;
var float Num3 = .1; //有效，但不推荐
```

由于浮点数保存需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换成整数值：

``` js
var floatNum1 = 1.; //小数点后面没有数字——解析为1
var floatNum2 = 10.0 //整数——解析为10
```

对于极大或极小的数值，用e表示法（科学计数法）：

``` js
var floatNum1 = 3.125e7; //就相当于是 3.123 × 10 ^7 即 31250000
var floatNum2 = 3e-7; //就是0.0000003
```

浮点数值的最高精度是17位小数，进行算术计算其精确度远不如整数，如：0.1加0.2的结果不是0.3，而是0.30000000000000004。

``` js
if (a + b == 0.3) { //不要做这样的测试！
    alert("You got 0.3."); 
}
//如果a、b两个数是0.05和0.25或者0.15和0.15都不会有问题，但是如果两个数是0.1和0.2，那么测试将无法通过。
```

####2. 数值范围

ECMAScript能够表示的最小数值保存在 Number.MIN_VALUE中，大多数浏览器中这个值为 5e-324，小于这个值就会被自动转换成 -Infinity（负无穷）；最大的值保存在 Number.MAX_VALUE中，大多数浏览器中这个值为 1.7976931348623157e+308，大于它会被转成 Infinity（正无穷）。

如果某次计算反回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算。可以用 isFinite() 函数确定一个数值是否是有穷的：

``` js
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false
```

> 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值。可以想见，这两个属性中分别保存着 -Infinity 和 Infinity 。

####3. NaN

NaN，即非数值（Not a Number）是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况。例如，在ECMAScript中，0除以0会返回NaN，不会抛出错误，影响其他代码的执行。（整数除以0得到Infinity；负数除以0得到 -Infinity）

NaN的两个特点：

1. 任何涉及NaN的操作（例如NaN/10）都会返回NaN。
2. NaN与任何值都不相等，包括NaN本身。例如：`alert(NaN == NaN); //false`

ECMAScript定义了isNaN()函数，来确定参数是否“不是数值”。任何不能被转换为数值的值都会导致这个函数返回true，例如：

``` js
alert(isNaN(NaN)); //true
alert(isNaN(10)); //false (10是一个数值)
alert(isNaN("10")); // false (可以被转换成数值10)
alert(isNaN("blue")); //true (不能转换成数值)
alert(isNaN(true)); //false (可以被转换成数值1)
```

> isNaN()也适用于对象，它会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则给予这个返回值再调用toString()方法，再测试返回值。

####数值转换

- Number() 函数，可用于任何数据类型
- parseInt() 函数，专门用于把字符串转换成数值
- parseFloat() 函数，专门用于把字符串转换成数值

**转型函数Number() 的转换规则**

- 如果是Boolean值，true和false将分别转换为1和0
- 如果是数字值，知识简单的传入和返回
- 如果是null值，返回0
- 如果是undefined，返回NaN。
- 如果是字符串，则
    - 如果字符串只包含数字（包含前面带正、负号的情况），则将其转换为十进制数值，即"1"会变成1；"123"会变成123，而"011"会变成11（注意，前导的零被忽略）
    - 如果字符串中包含有效的浮点格式，如"1.1"，则将会转换为对应的浮点数值（前导零也会被忽略）
    - 如果字符串中包含有效的十六进制格式，例如"0xf"，则转换为相同大小的十进制整数值
    - 如果字符串为空（不包含任何字符），则转换为0
    - 如果字符串中包含上述格式之外的字符，则转换为NaN
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

``` js
var num1 = Number("Hello world!"); //NaN
var num2 = number(""); //0
var num3 = Number("000011"); //11
var num4 = Number(true); //1
```

**parseInt() 函数**

- 它会忽略字符串前面的空格，直至找到第一个非空格字符串
- 如果第一个字符不是数字字符或者负号，则返回NaN，例如`alert(parseInt("hi123")); //NaN`
- 转换空字符串，会返回NaN：`alert(parseInt("")); //NaN`
- 如果第一个字符是数字字符，则会继续解析第二个字符，直至解析完所有后续字符或者遇到了一个非数字字符。例如：`alert(parseInt("1234blue")); //1234`。又如：`alert(parseInt("22.5")); //22 因为小数点不是有效的数字字符`
- 也能够识别出各种整数格式，如果字符串以"0x"开头且后跟数字字符，就会当作一个十六进制整数；如果字符串以"0"开头且后跟数字字符，则会当作八进制数来解析。

``` js
var num1 = parseInt("1234blue"); //1234
var num2 = parseInt(""); //NaN
var num3 = parseInt("0xA"); //10 （十六进制数）
var num4 = parseInt(22.5); //22
var num5 = parseInt("070"); //56 （八进制数）
var num6 = parseInt("70"); //70 （十进制数）
var num7 = parseInt("0xf"); //15 （十六进制数）
```

> ECMAScript 3 JS引擎与5的JS引擎有区别。`var num = parseInt("070");` 在3中被认为是56（八进制）；在5中认为是70（十进制）

parseInt()函数的第二个参数：转换时使用的基数（即多少进制）：

``` js
var num = parseInt("0xAF", 16); //175
var num1 = parseInt("AF", 16); //175 指定了进制之后，字符串前面可以不带"0x"
var num2 = parseInt("AF"); //NaN
```

指定基数会影响到转换的输出结果，如：

``` js
var num1 = parseInt("10", 2); //2 （按二进制解析）
var num2 = parseInt("10", 8); //8 （按八进制解析）
var num3 = parseInt("10", 10); //10 （按十进制解析）
var num4 = parseInt("10", 16); //16 （按十六进制解析）
```

**parseFloat()函数**

- 从第一个字符（位置0）开始解析每个字符，一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。（字符串中第一个小数点是有效的，第二个小数点是无效的），如：`parseFloat("22.34.5"); //22.34`
- parseFloat()之中会忽略前导的零，它只解析十进制值，它没有第二个参数指定进制。十六进制的字符串始终解析为0，如`parseFloat("0xA"); //0`
- 如果字符串包含的是一个课解析为整数的数（没有小数点，或者小数点后都是零），那么parseFloat()会返回整数

``` js
var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000
```

###3.4.6 String类型

String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。可由双引号（"）或单引号（'）表示。用双引号或单引号表示的字符串完全相同。不过以双引号开头的字符串必须以双引号结尾；以单引号开头的字符串必须以单引号结尾，即左右引号必须匹配。

####1. 字符字面量

字面量 | 含义
:--|:--
\n | 换行
\t | 制表
\b | 空格
\r | 回车
\f | 进纸
\\ | 斜杠
\' | 单引号（'），在用单引号表示的字符串中使用，例如：`'He said, \'hey.\''`
\" | 双引号（"），在用双引号表示的字符串中使用，例如：`"He said, \"hey.\""`
\xnn | 以十六进制代码nn表示的一个字符（其中n为0~F）。例如，\x41表示"A"
\unnnn | 以十六进制代码nnnn表示一个Unicode字符（其中n为0~F）。例如，\u03a3表示希腊字符∑

以上这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析。如：

``` js
var text = "This is the letter sigma: \u03a3.";
alert(text.length); //输出28
```

####2. 字符串的特点

ECMAScript中的字符串是不可变的，即字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首相要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。例如：

``` js
var lang = "Java";
lang = lang + "Script";
```

以上示例的实现过程如下：先创建一个能容纳10个字符的新字符串，然后在这个字符串中填空“Java”和“Script”，最后一步是销毁原来的字符串“Java”和字符串“Script”。

####3. 转换为字符串

**方法一：toString()方法**

- 数值、布尔值、对象和字符串值（每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法
- null和undefined值没有这个方法，会报错
- 在调用数值的toString()方法时，可以传递一个参数，输出数值的基数，默认情况下，toString()方法以十进制格式返回数值的字符串表示。

``` js
var age = 11;
var ageAsString = age.toString(); //字符串"11"
var found = true;
var foundAsString = found.toString(); //字符串"true"

var num = 10;
alert(num.toString()); //"10"
alert(num.toString(2)); //"1010"
alert(num.toString(8)); //"12"
alert(num.toString(10)); //10
alert(num.toString(16)); //"a"
```

**方法二：转型函数String()**

在不知道要转换的值是不是null或undefined的情况下，还可以使用String()，它可以将任何类型的值转换为字符串。规则如下：

- 如果值有toString()方法，则调用该方法（没有参数），并返回相应结果
- 如果值是null，则返回"null"
- 如果值是undefined，则返回"undefined"

``` js
var value1 = 10;
var value2 = true;
var value3 = null;
var value4;

alert(String(value1)); //"10"
alert(String(value2)); //true;
alert(String(value3)); "null"
alert(String(value4)); "undefined"
```

**方法三：要把某个值转换为字符串，可以使用加号操作符把它与一个字符串("")加在一起**

###3.4.7 Object类型

ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如：`var o = new Object();`。

如果不给构造函数传递参数，则可以省略后面的那一对圆括号，但是并不推荐这样做。如：`var o = new Object; //有效，但不推荐省略圆括号`。

在ECMAScript中，Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。

Object的每个实例都具有下列属性和方法：

- constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
- hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定，例如：`o.hasOwnProperty("name")`。
- isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。作为参数的属性名必须以字符串形式指定。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

>从技术角度讲，ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。

##3.5 操作符

###3.5.1 一元操作符

只能操作一个值的操作符叫做一元操作符。

####1. 递增和递减操作符

- 前置型 `var age = 29; ++age;`、`var age = 29; --age;`
    - 执行前置的递增和递减操作时，变量的值都是在语句被求值以前改变的。

``` js
var age = 29;
var anotherAge = --age +2;

alert(age); //输出29
alert(anotherAge); //输出30
```

由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值，又如：

``` js
var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2; //等于21
var num4 = num1 + nu2; //等于21
```

- 后置型 ` var age = 29; age++;`
    - 后置型递增和递减操作是在包含它们的语句被求值之后才执行的

``` js
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2; //等于22
var num4 = num1 + num2; //等于21
```

前、后置型递增、递减操作符对于任何值都适用，也就是说它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用不同的值时，递增和递减操作符遵循下列规则。

- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变成数值变量。
- 在应用于布尔值false时，先将其转换成0再执行加减1的操作。布尔值变量变成数值变量。
- 在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时，执行加减1的操作。
- 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值，然后对该值应用前述规则。如果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

``` js
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function(){
        return -1;
    }
};

s1++; //值变成数值3
s2++; //值变成NaN
b++; //值变成数值1
f--; //值变成0.10000000000000009（由于浮点舍入错误所致）
o--; //值变成数值-2
```

####2. 一元加和减操作符

一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。如：

``` js
var num = 25;
num = +num; //仍然是25
```

不过，对于非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。即：布尔值false和true将被转换为0和1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的valueOf()和（或）toString()方法，再转换得到的值。例如：

``` js
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function(){
        return -1;
    }
};

s1 = +s1; //值变成数值1
s2 = +s2; //值变成数值1.1
s3 = +s3; //值变成NaN
b = +b; //值变成数值0
f = +f; //值未变，仍然是1.1
o = +o; //值变成数值-1
```

一元减操作符主要用于表示负数，例如将1转换成-1。

``` js
var num = 25;
num = -num; //变成了-25
``` 

当一元减操作符应用于非数值时，遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，例如：

``` js
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function(){
        return -1;
    }
};

s1 = -s1; //值变成数值-1
s2 = -s2; //值变成数值-1.1
s3 = -s3; //值变成NaN
b = -b; //值变成数值0
f = -f; //值未变，仍然是-1.1
o = -o; //值变成数值1
```

###3.5.2 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中的所有数值都以IEEE-754 64位格式存储，但是位操作符并不直接操作64位的值，而是先将64位的值转换成32位的整数，然后执行操作。

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示整数，1表示负数。这个表示符号的位叫做符号位。符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31位中的每一位都表示2的幂。第一位（叫做位0）表示2<sup>0</sup>，第二位表示2<sup>1</sup>以此类推。没有用到的位以0填充，即忽略不计。例如，数值18的二进制表示是00000000000000000000000000010010，或者更简洁的10010。（2<sup>4</sup> * 1 + 2<sup>3</sup> * 0 + 2<sup>2</sup> * 0 + 2<sup>1</sup> * 1 + 2<sup>0</sup> * 0 = 18）

负数同样以二进制码存储，但使用的格式是**二进制补码**。计算一个数值的二进制补码，需要经过下列3个步骤：

1. 求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码）
2. 求二进制反码，即将0替换为1，将1替换为0
3. 得到的二进制反码加1

例如要求-18的二进制码：

1. 18的二进制码是：0000 0000 0000 0000 0000 0000 0001 0010
2. 求二进制反码，0、1互换：1111 1111 1111 1111 1111 1111 1110 1101
3. 二进制反码加1：1111 1111 1111 1111 1111 1111 1110 1110

> 注意：在处理有符号整数时，是不能访问位31的。

ECMAScript在以二进制字符串形式输出一个负数时，我们只是看到了这个负数绝对值的二进制码前面加上了一个负号：

``` js
var num = -18;
alert(num.toString(2)); //"-10010"
```

> 默认情况下，ECMAScript中的所有整数都是有符号整数。不过，当然也存在无符号整数。对于无符号整数来说，第32位不再表示符号，因为无符号整数只能是正数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示数值。

在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。

如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后再应用位操作符。得到的结果将是一个数值。

####1. 按位非（NOT）

按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。按位非的操作本质：操作数的负值减1.

``` js
var num1 = 25; //二进制 00000000000000000000000000011001
var num2 = ~num1; //二进制 11111111111111111111111111100110
alert(num2); //-26
```

上述代码与下面的代码效果相同，但是上面的代码更快：

``` js
var num1 = 25;
var num2 = -num1 - 1;
alert(num2); //"-26"
```

####2. 按位与（AND）

按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行AND操作：

第一个数值的位 | 第二个数值的位 | 结果
:-- | :-- | :--
1 | 1 | 1
1 | 0 | 0
0 | 1 | 0
0 | 0 | 0

简而言之：按位与操作只有在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0.

``` js
var result = 25 & 3;
//25: 0000 0000 0000 0000 0000 0000 0001 1001
// 3:  0000 0000 0000 0000 0000 0000 0000 0011
alert(result); //1: 0000 0000 0000 0000 0000 0000 0000 0001
```

####3. 按位或（OR）

按位或操作符由一个竖线符号（|）表示，同样也有两个操作符，按位或操作遵循下面这个真值表：

第一个数值的位 | 第二个数值的位 | 结果
:-- | :-- | :--
1 | 1 | 1
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

简而言之，按位或操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0.

``` js
var result = 25 | 3;
//25: 0000 0000 0000 0000 0000 0000 0001 1001
// 3:  0000 0000 0000 0000 0000 0000 0000 0011
alert(result); //27: 0000 0000 0000 0000 0000 0000 0001 1011
```

####4. 按位异或（XOR）

按位异或操作符由一个插入符号（^）表示，也有两个操作数，一下是按位异或的真值表。

第一个数值的位 | 第二个数值的位 | 结果
:-- | :-- | :--
1 | 1 | 0
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或都是0，则返回0.

``` js
var result = 25 ^ 3;
//25: 0000 0000 0000 0000 0000 0000 0001 1001
// 3:  0000 0000 0000 0000 0000 0000 0000 0011
alert(result); //26: 0000 0000 0000 0000 0000 0000 0001 1010
```

####5. 左移

左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，如果将数值2（二进制码为10）向左移动5位，结果就是64（二进制码为1000000）。

``` js
var oldValue = 2; //等于二进制的10
var newValue = oldValue << 5; //等于二进制的1000000，十进制的64
```

> 向左移位后，原数值右侧多出来的空位用0来填充，以便得到的结果是一个完整的32位二进制数。
> 左移不会影响操作数的符号位。换句话说，如果将-2向左移动5位，结果将是-64。

####6. 有符号的右移

有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。

``` js
var oldValue = 64; //等于二进制的1000000
var newValue = oldValue >> 5; //等于二进制的10，即十进制的2
```

>由于右移而出现在符号位右侧、原数值左侧的空位，用符号位的值来填充。

####7. 无符号右移

无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。

``` js
var oldValue = 64; //等于二进制的1000000
var newValue = oldValue >>> 5; //等于二进制的10，即十进制的2
```

对于负数来说，情况不同。无符号右移是以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位。无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如：

``` js
var oldValue = -64; //等于二进制的11111111111111111111111111000000
var newValue = oldValue >>> 5; //等于十进制的134217726: 00000111111111111111111111111110
```

###3.5.3 布尔操作符

####1. 逻辑非

逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。

- 如果操作数是一个对象，返回false
- 如果操作数是一个空字符串，返回true
- 如果操作数是一个非空字符串，返回false
- 如果操作数是数值0，返回true
- 如果操作数是任何非0数值（包括Infinity），返回false
- 如果操作数是null，返回true
- 如果操作数是NaN，返回true
- 如果操作数是undefined，返回true

``` js
alert(!false); //true
alert(!"blue"); //false
alert(!0); //true
alert(!NaN); //true
alert(!""); //true
alert(!12345); //false
```

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。

``` js
alert(!!"blue"); //true 
alert(!!0); //false 
alert(!!NaN);  //false 
alert(!!"");  //false 
alert(!!12345); //true
```

####2. 逻辑与

逻辑与操作符由两个和号（&&）表示，有两个操作数。逻辑与的真值表如下：

第一个操作数 | 第二个操作数 | 结果
:-- | :-- | :--
true | true | true
true | false | false
false | true | false
false | false | false

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第二个操作数
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才返回该对象。
- 如果两个操作数都是对象，则返回第二个操作数
- 如果有一个操作数是null，则返回null
- 如果有一个操作数是NaN，则返回NaN
- 如果有一个操作数是undefined，则返回undefined

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是false，则无论第二个操作数是什么值，结构都不再可能是true了。下面的例子充分说明逻辑与属于短路操作：

``` js
var found = true;
var result = (found && someUndefinedVariable); //这里会发生错误
alert(result); //这一行不会执行
```

但是，

``` js
var found = false;
var result = (found && someUndefinedVariable); //不会发生错误，因为就根本没有求someUndefinedVariable的值
alert(result); //会执行("false")
```

####3. 逻辑或

逻辑或操作符由两个竖线符号（||）表示，有两个操作符。逻辑或的真值表如下：

第一个操作数 | 第二个操作数 | 结果
:-- | :-- | :--
true | true | true
true | false | true
false | true | true
false | false | false

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值。此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第一个操作数
- 如果第一个操作数的求值结果为false，则返回第二个操作数
- 如果两个操作数都是对象，则返回第一个操作数
- 如果两个操作数都是null，则返回null
- 如果两个操作数都是NaN，则返回NaN
- 如果两个操作数都是undefined，则返回undefined

逻辑或操作符也是短路操作符，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

``` js
var found = true;
var result = (found || someUndefinedVariable); //不会发生错误
alert(result); //会执行 ("true")
```

但是，

``` js
var found = false;
var result = (found || someUndefinedVariable); //这里会发生错误
alert(result); //这一行不会执行
```

我们可以利用逻辑或这一行为来避免为变量赋null或undefined值，例如：`var myObject = preferredObject || backupObject;`。

###3.5.4 乘性操作符

乘性操作符包括：乘法、除法和求模。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值，即空字符串被当作0，布尔值true被当作1。

####1. 乘法

乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

- 如果操作数都是数值，执行常规的乘法计算。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity。
- 如果有一个操作数是NaN，则结果为NaN
- 如果是Infinity与0相乘，则结果是NaN
- 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号
- 如果是Infinity与Infinity相乘，则结果是Infinity
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

####2. 除法

除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算。规则如下：

- 如果操作数都是数值，执行常规的除法计算。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity
- 如果有一个操作数是NaN，则结果是NaN
- 如果是Infinity被Infinity除，则结果是NaN
- 如果是零被零除，则结果是NaN
- 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号
- 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

####3. 求模

求模（余数）操作符由一个百分号（%）表示，遵循如下规则：

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数
- 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN
- 如果被除数是有限大的数值而除数是零，则结果是 NaN
- 如果是 Infinity 被 Infinity 除，则结果是 NaN
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数
- 如果被除数是零，则结果是零
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

###3.5.5 加性操作符

加性操作符也会在后台转换不同的数据类型，且转换规则还比较复杂。

####1. 加法

加法操作符（+）。如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

- 如果两个操作符都是数值，则执行常规的算术加法操作并返回结果
- 如果有一个操作数是NaN，则结果是NaN
- 如果是Infinity加Infinity，则结果是Infinity
- 如果是-Infinity加-Infinity，则结果是-Infinity
- 如果是Infinity加-Infinity，则结果是NaN
- 如果是+0加+0，则结果是+0
- 如果是-0加-0，则结果是-0
- 如果是+0加-0，则结果是+0
- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来
- 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则
- 对于undefined和null，分别调用String()函数并取得字符串"undefined"和"null"

``` js
var result1 = 5 + 5; //两个数值相加
alert(result1); //10
var result2 = 5 + "5"; //一个数值和一个字符串相加
alert(result2); //"55"
```

常见错误：

``` js
var num1 = 5;
var num2 = 10;
var message = "The sum of 5 and 10 is " + num1 + num2;
alert(message); //"The sum of 5 and 10 is 510"
```

应更改为：

``` js
var num1 = 5;
var num2 = 10;
var message = "The sum of 5 and 10 is " + (num1 + num2); //注意这里圆括号的使用
alert(message); //"The sum of 5 and 10 is 15"
```

####2. 减法

减法操作符（-），在处理各种数据类型转换时，同样需要遵循一些特殊规则：

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果
- 如果有一个操作数是NaN，则结果是NaN
- 如果是Infinity减Infinity，则结果是NaN
- 如果是-Infinity减-Infinity，则结果是NaN
- 如果是Infinity减-Infinity，则结果是Infinity
- 如果是-Infinity减Infinity，则结果是-Infinity
- 如果是+0减+0，则结果是+0
- 如果是+0减-0，则结果是-0
- 如果是-0减-0，则结果是+0
- 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN
- 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

``` js
var result1 = 5 - true; //4，因为true被转换成了1
var result2 = NaN - 1; //NaN
var result3 = 5 - 3; //2
var result4 = 5 - ""; //5，因为""被转换成了0
var result5 = 5 - "2"; //3， 因为"2"被转换成了2
var result6 = 5 - null; //5，因为null被转换成了0
```
